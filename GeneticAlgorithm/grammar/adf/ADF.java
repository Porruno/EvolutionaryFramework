package grammar.adf;

import geneticAlgorithm.Genome;
import geneticAlgorithm.Population;
import grammar.Function;
import grammar.adf.ADFDelegate.ADFType;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * An ADF is an automtic defined function. In this particular case, an ADF is
 * the group of automatic defined functions generated by a population. The
 * populations in charge of producing ADFs are always different from the main
 * population, and so, they evolve in a different way that the main population.
 * The population that generates an ADF can use other ADFs as its compontents,
 * but circular can't be configured.
 *
 * @author Jesús Irais González Romero
 */
public class ADF extends Function {

    protected Population population;
    protected ADFDelegate adfDelegate;
    protected int index;
    protected Class<?> adfInputClass;

    /**
     * Constructs an adf.
     *
     * @param index The index that this adf occupies in the population that is
     * creating it.
     * @param adfDelegate Delegetae that knows how this adf must be constructed.
     */
    public ADF(int index, ADFDelegate adfDelegate) {
        this.index = index;
        this.adfDelegate = adfDelegate;
        this.parameterTypes = this.adfDelegate.getParameterTypes();
        this.population = adfDelegate.getPopulationDelegate().getPopultion();
        this.adfInputClass = adfDelegate.getADFInputClass();
        this.returnType = this.population.getReturnType();
        this.name = "ADF:" + index;
        checkIfIsTerminal();
    }

    /**
     * Evaluates this ADF given an array of parameters.
     *
     * @param parameters An array of 2 + n parameters. The first paramater is an
     * Integer that indicates the index of the genome to evaluate. The second
     * parameter indicates if the first parameter refers to the arraylist that
     * contains the whole population (if false) or to the arraylist that
     * contains only new genomes (if true). The other n parameters are the
     * parameters that the specified genome requires to be evaluated.
     * @return The result of evaluating the specified genome with the n
     * specified parameters.
     */
    @Override
    public Object evaluate(Object... parameters) {
        try {
            int genomeIndex = (Integer) parameters[0];
            boolean onlyNewGeneration = (Boolean) parameters[1] && this.getADFType() == ADFType.COEVOLUTIVE;

            Object[] parametersForADF = new Object[this.getParameterTypes().length];
            for (int i = 2; i < parameters.length; i++) {
                parametersForADF[i - 2] = parameters[i];
            }
            ADFInput adfInput;
            Constructor<?> constructor = adfInputClass.getConstructor();
            adfInput = (ADFInput) constructor.newInstance();
            for (int i = 0; i < parametersForADF.length; i++) {
                adfInput.addParameter(parametersForADF[i]);
            }
            adfInput.init();
            return population.getGenomeAtIndex(genomeIndex, onlyNewGeneration).evaluate(adfInput);
        } catch (InstantiationException ex) {
            Logger.getLogger(ADF.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            Logger.getLogger(ADF.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IllegalArgumentException ex) {
            Logger.getLogger(ADF.class.getName()).log(Level.SEVERE, null, ex);
        } catch (InvocationTargetException ex) {
            Logger.getLogger(ADF.class.getName()).log(Level.SEVERE, null, ex);
        } catch (NoSuchMethodException ex) {
            Logger.getLogger(ADF.class.getName()).log(Level.SEVERE, null, ex);
        } catch (SecurityException ex) {
            Logger.getLogger(ADF.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * Since an ADF is a population, it needs to be evolved. However, its
     * evolution depends on the type of ADF. If it's an ADF coevolutive or semi-
     * coevolutive, evolution occurs as in the main population; In the case
     * of an ADF simple, this method does nothing and the actual evolution
     * occurs when the population that is using this ADF evolves.
     * method will return without evolving the population.
     * 
     */
    public void evolve() {
        if (this.getADFType() != ADFType.SIMPLE) {
            Genome[] newGeneration = this.population.generateNextGeneration();
            this.population.replaceOldGenomes(newGeneration);
        }
        this.population.increaseGeneration();
    }

    /**
     * This method is intended to be used only to evolve genomes from a simple
     * ADF. It Takes 2 genomes and recombinates them. Then it mutates each genome.
     * Finally it inserts the new genomes into the population by eliminating 
     * the 2 worst genomes.
     * @param adf1 one of the two genomes to evolve.
     * @param adf2 one of the two genomes to evolve.
     */
    public void evolveAPair(Genome adf1, Genome adf2) {
        adf1.setIsFromNewGeneration(false);
        adf2.setIsFromNewGeneration(false);
        Genome[] parents = {adf1, adf2};

        Genome[] descendants = this.population.replicateGenomes(parents);
        this.population.recombinateGenomes(descendants);
        this.population.mutation(descendants);
        for (Genome genome : descendants) {
            genome.prepareForNextGeneration();
        }
        this.population.replaceOldGenomes(descendants);
    }

    /**
     * @return An array with the classes of the parameters that all the genomes of this ADF's population
     * uses.
     */
    @Override
    public Class<?>[] getParameterTypes() {
        return this.adfDelegate.getParameterTypes();
    }

    /**
     * @return This ADF's index in the population that uses it.
     */
    public int getIndex() {
        return this.index;
    }

    /**
     * @return This ADF's population's size.
     */
    public int getPopulationSize() {
        return this.population.getPopulationSize();
    }

    /**
     * @return The replacement size of this ADF's population.
     */
    public int getNewGenerationSize() {
        return this.population.getReplacementSize();
    }

    /**
     * @return The return type of all the genomes generated by this ADF's population.
     */
    public ADFType getADFType() {
        return this.adfDelegate.getADFType();
    }

    /**
     * When a genome that uses this ADF is evaluated, it sends the aptitutde that
     * it was given to him by the evaluator via this method to the used genome.
     * @param aptitude The aptitude given to the genome that uses this ADF.
     * @param genomeIndex The index of the genome used by the evaluated genome
     * from all the genomes in this ADF's population.
     */
    public void sendAptitudeToGenome(double aptitude, int genomeIndex) {
        Genome genome = this.population.getCompletePopulation()[genomeIndex];
        genome.sendAptitude(aptitude);
    }

    /**
     * Utility function used to reset the aptitudes of all the genomes that
     * have been recently generated, which are actually copy of other genomes, and so,
     * it has a fake aptitude.
     */
    public void resetAptitudesOfNewGeneration() {
        this.population.resetAptitudesOfNewGeneration();
    }

    /**
     * Prepares the info about the ADFs that this ADF's population uses. This 
     * is needed because an ADF's population can also use other ADFs.
     */
    public void prepareInfoAboutADFs() {
        this.population.prepareInfoAboutADFs();
    }

    /**
     * @return This ADF's population.
     */
    public Population getPopulation() {
        return this.population;
    }
}